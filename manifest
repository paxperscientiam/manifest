#!/usr/bin/env bash
###################################
# Disclaimer: THIS IS AN ACTIVE EXPERIMENT. EXECUTE AT YOUR OWN PERIL.
###################################
# SECTION: News.

###################################
# Manifest -- a project dedicated to the paranoid.
# Manifest is written for and tested on Bash on OSX.
# Purpose: To generate and maintain 'manifests' of applications/gems/modules/packages/ports/etc.
## To mirror a user's environment.
# Execution: To be run either as a cron job or from a shell.
###################################
# SECTION: Requirements.
###################################
# Bash 4.2
# Pallet and Cask for Emacs 24
###################################
# SECTION: Variables.
###################################
# Script Owner (GNU Bash on Darwin)
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
_CWD="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
#
_OWNER="$(/usr/bin/stat -f %Su "${BASH_SOURCE[0]}")" # Find script owner
_RC_CWD="${_CWD}/.manifestrc"
_RC_HOME="${HOME}/.manifestrc"
#
_LOG="${HOME}/Library/logs/manifest.log"
###################################
# SECTION: Prepare environment.
###################################
# required for nice globbing stuff
## resets
_BASE=
_isTerm=

#cannot be null!
osxNote=0
ttyNote=0
logNote=0
verbosity=0

## Check for version number
_Major="${BASH_VERSINFO[0]}"
_Minor="${BASH_VERSINFO[1]}"
_Version="${_Major}.${_Minor}"
_requiredVersion=4.2
#
_NS="MANIFEST"
#
notify () {
  if ((messageStatus & verbosity)); then
    msg="${1}${2}"
  else
    msg="${1}"
  fi

  if ((messageStatus & notify)); then
    osascript -e "display notification \"$msg\" with title \"manifest \""
  fi
  if ((messageStatus & stdout)); then
    printf '%s.\n' "${1}" >/dev/tty
  fi
  if ((messageStatus & log)); then
    echo "LOOOOL"
  fi
}
notify=$((1<<0))
stdout=$((1<<1))
log=$((1<<2))


messageHandler() {
  n=$(($1*notify))
  s=$(($2*stdout))
  l=$(($3*log))
  #
  return $((n|s|l))
}

checkVersion () {
  if [[ $_Major -ge 4 && $_Minor -ge 2 ]]; then
    notify 'Version requirement met.'
  else
    notify "Fail!" "Version ${_requiredVersion} is required!"
    exit 1
  fi
}

# check for config file
checkRC () {
  if [[ -f "${_RC_CWD}" ]]; then
    #    notify "RC file found in current working directory."
    . "${_RC_CWD}"
  elif [[ -f "${_RC_HOME}" ]]; then
    #   notify "RC file found in home directory."
    . "${_RC_HOME}"
    return
  else
    printf '%s' 'Configuration file is required!'
    exit 1
  fi
}
checkRC
checkVersion
messageHandler "${osxNote}" 0 "${logNote}"
messageStatus=$?




###############################

init () {
  ## terminal check
  if [[ -t 0  || -t 1 ]]; then
    notify "Running in Terminal."
    _isTerm=1
  else
    notify 'Not-a-terminal.\n'
    _isTerm=0
  fi
  ##
  ##
  ##
  ##
  # _BASE *must* be defined and non-null
  if [[ -v _BASE && -n "${_BASE}" && -d "/${_BASE}/" ]]; then
    notify "_BASE is defined" " as ${_BASE,,//\/\//\/}"
  else
    notify '_BASE must be defined and directory path must exist!'
    exit 1
  fi
  #
  if [[ ! -v osxNote && ! -n "${osxNote}" ]]; then
    printf '%s' "osxNote must be defined and non-null!"
    exit 1
  fi
  #
  if [[ ! -v ttyNote && ! -n "${ttyNote}" ]]; then
    printf '%s' "ttyNote must be defined and non-null!"
    exit 1
  fi
  #
  if [[ ! -v logNote && ! -n "${logNote}" ]]; then
    printf '%s' "logNote must be defined and non-null!"
    exit 1
  fi



}
# Reset log file. (user should have a choice in the matter)
#>"${_LOG}" # create/reset log, might be causing trouble with readline

###################################
# SECTION: Primary Functions.
###################################
# FUNCTION: Main
__manifest() {
  notify "manifest core is running."
  notify "That is all, ${_OWNER}! (^.^)"
}
#

#
# FUNCTION: Copy dotfiles.
__dot() {
  # Ensure the directory exists.
  if [[ $1 == 'help' ]]; then
    printf 'Backup User dotFiles found in the HOME directory.\n'
    exit 0
  fi
  # shellcheck disable=2174
  mkdir -p -m 744 "${_BASE}/dots/"
  rsync -cpRz "${HOME}"/.??*[!~$] "${_BASE}/dots/"
  rm -f "${_BASE}/dots/CLONE"*
  touch "${_BASE}/dots/CLONE.$(timeStamp)"
  #
  notify "${FUNCNAME[0]#__} is complete."
}
#
#
# FUNCTION manifest of background services
__services () {
  type lunchy &>/dev/null || { printf "I require the lunchy gem but it's not installed. Aborting."; exit 1;}

  saveFile "${USER}.background-services.txt" "`lunchy list`"

  notify "Generating ${FUNCNAME[0]#__} manifest of ${_OWNER}..."
  notify "${FUNCNAME[0]} is complete."
}
#
# composer global
__composer() {
  type compsoser &>/dev/null
  [[ $? -ne 0 ]] && printf "I require  but it's not installed. Aborting."; exit 1;
  if [[ -z "${COMPOSER_HOME}" ]];then
    COMPOSER_HOME="${HOME}/composer.json"
  fi
  if [[ -r "${COMPOSER_HOME}/composer.json" ]]; then
    /bin/cp "${COMPOSER_HOME}/composer.json" "${_BASE}"
  fi
}

# FUNCTION: Generate 'Gemfile' to use for reinstalling 'local' gems.
__gem() {
  if [[ $1 == 'help' ]]; then
    printf 'Create an execute-ready manifest of ruby gems.\n'
    exit 0
  fi
  #
  type gem &>/dev/null || { printf "I require GEM but it's not installed. Aborting."; exit 1;}
  gemv=$(gem --version)
  # need to properly parse output so that it can used on the command line
  notify "Generating ${FUNCNAME[0]#__} manifest..."
  #thanks to arturkomarov @ disqus

  saveFile "local.gems.${gemv}.txt" \
           "`gem list | sed 's/(//'|sed 's/)//'|awk '{print "gem install " $1 " --version=" $2}'`"

  #
  notify "${FUNCNAME[0]#__} is complete."
}

#
# FUNCTION: Generate a 'package.json' for NPM global modules.
__npm() {
  if [[ $1 == 'help' ]]; then
    printf 'Create a manifest of global npm modules.\n'
    exit 0
  fi
  type npm &>/dev/null || { echo >&2 "I require npm but it's not installed. Aborting."; exit 1;}
  #npmv=$(npm --version)
  nodev=$(node --version)

  notify "Generating ${FUNCNAME[0]#__} manifest..."

  saveFile "npm-global.${nodev}.json" "`npm -g ls --json true --parseable true --depth=0`"

  #
  # continue
  notify "${FUNCNAME[0]#__} is complete."
}
#
# FUNCTION: Emacs stuff.
__emacs() {

  if [[ $1 == 'help' ]]; then
    printf 'Emacs is the One True Editor.\n'
    exit 0
  fi
  #test
  type emacs &>/dev/null || { echo >&2 "I require emacs but it's not installed. Aborting."; exit 1;}
  #
  # generate cask file
  emacs --batch --eval "(progn (package-initialize)
(if (bound-and-true-p pallet-mode)
(pallet-init)
(progn
(pallet-mode)
(pallet-init))))"

  #
  notify "Generating ${FUNCNAME[0]#__} (cask) manifest..."
  cp -p "${HOME}/.emacs.d/Cask" "${_BASE}/cask.txt"
  #
  notify "${FUNCNAME[0]#__} is complete."

}
#


# Function: create system apps manifest.
__sysApps() {
  if [[ $1 == 'help' ]]; then
    printf 'Create a manifest of Applications.\n'
    exit 0
  fi
  #
  notify "Generating $(sw_vers -productVersion) manifest..."

  saveFile "system.apps.txt" "`mdfind -onlyin /Applications/ kMDItemKind == Application | tee >(wc -l) | sort -f`"

  notify "${FUNCNAME[0]} is complete."
}
#

getPYVersion() {
  python << EOF
import sys
print "%s%s" % (sys.version_info[0] , sys.version_info[1])
EOF
}
pyv=$(getPYVersion)


__pip() {
  type pip &>/dev/null  || { echo >&2 "I require pip, but it's not installed. Aborting."; exit 1; }

  notify "Generating ${FUNCNAME[0]#__} manifest..."
  saveFile "pip.py${pyv}.txt" "`pip --isolated freeze`"
  notify "done."
}


# # manifest of all installed macports ports
__port() {
  if [[ $1 == 'help' ]]; then
    printf 'Create a manifest of installed and requested Macports ports.\n'
    exit 0
  fi

  type port &>/dev/null  || { echo >&2 "I require the Macports port, but it's not installed. Aborting."; exit 1; }
  # Credit: Macports
  notify "Generating ${FUNCNAME[0]#__} manifest..."

  saveFile "system.macports.txt" "`port -qv installed`"

  notify "done."

  notify "Creating manifest of requested ports..."

  #saveFile "system.macports-requested.txt" `port echo requested | cut -d ' ' -f 1"`

  port echo requested | cut -d ' ' -f 1 > "${_BASE}system.macports-requested.txt"
  #
  notify "${FUNCNAME[0]#__} is complete."
}
#
__cron() {
  # crontabs
  notify "Replicating crontab of user ${_OWNER}"
  crontab -l > "${_BASE}${USER}.crontab.txt"
  #
  notify "${FUNCNAME[0]#__} is complete."
}
#
#
# __apache() {
#   if [[ $1 == 'help' ]]; then
# This option will copy important server files.
#     exit 0
#   fi
#   type httpd &>/dev/null || { echo >&2 "I require HTTPD but it's not installed. Aborting."; exit 1;}
#   # Permissions?
#   _HTTPD_ROOT="$(httpd -V | grep -Po '(?<=HTTPD_ROOT\=\")[^"]*')"
#   _HTTPD_SERVER_CONFIG="${_HTTPD_ROOT}/$(httpd -V | grep -Po '(?<=SERVER_CONFIG_FILE\=\")[^"]*')"
#   _HTTPD_VHOST_CONFIG="${_HTTPD_ROOT}/conf/extra/httpd-vhosts.conf"
#   _HTTPD_MIME_CONFIG="${_HTTPD_ROOT}/$(httpd -V | grep -Po '(?<=AP_TYPES_CONFIG_FILE\=\")[^"]*')"

#   #backup includes
#   while IFS= read -r result
#   do
#     cp -p "${_HTTPD_ROOT}/${result}" "${_BASE}/serverFiles/"
#   done < <(grep -iPo "(?<=include\s).*conf\/.*" /opt/local/apache2/conf/httpd.conf)


# #type php &>/dev/null || { echo >&2 "I require HTTPD but it's not installed. Aborting."; exit 1;}

# _PHP_INI="$(php -r 'echo php_ini_loaded_file();')"


# # shellcheck disable=2174
# mkdir -p -m 744 "${_BASE}/serverFiles/"
# #
# cp -p "${_HTTPD_SERVER_CONFIG}" \
  #    "${_PHP_INI}" \
  #    "${_HTTPD_VHOST_CONFIG}" \
  #    '/etc/resolv.conf' \
  #    '/etc/hosts' \
  #    '/opt/local/etc/dnsmasq.conf' \
  #    '/opt/local/apache2/conf/extra/mod_php56.conf' \
  #    "${_HTTPD_MIME_CONFIG}" "${_BASE}/serverFiles/"

# notify "${FUNCNAME[0]} is complete."
# }

#
__getUser() {
  /usr/bin/stat -f %Su "${BASH_SOURCE[0]}"
}
#
###################################
# SECTION: Auxilary Functions.
###################################
# FUNCTION:

saveFile() {
  FN="${1}"
  shift
  echo "${@}" &> "${_BASE}${_NS}.${FN}"
}

errorHandle() {
  osascript -e 'display notification "Someone setup us the bomb!" with title "Sorry, a system error occurred."'
}

# FUNCTION:
timeStamp() {
  date +%Y.%m.%d.%H.%M.%S
}
#
#
###################################
# SECTION: Execute.
###################################
# Menu functions
func_menu_help() {
  BOLD=$(tput bold)
  NORM=$(tput sgr0)
  cat <<EOM
${BOLD}
manifest -- execute, in case of Doomsday.
A Bash program that generates parseable package manifests using the
syntax of respective package managers. All designed with love for the paranoid.${NORM}

-c: show config (RC) file
-f: list functions; takes optional argument
-i: interactively create a .manifestrc file
-q: quiet mode
-v: print version
-h: get help, seriously
EOM
}
#
#
#
init
#
#
if ((!$#))
then
  __manifest
else
  while getopts acfinq:tvh FLAG; do
    case $FLAG in
      a) #set a
        shift $((OPTIND-1))
	echo win >/dev/tty
	exit 0
	;;
      c) #--config
        shift $((OPTIND-1))
        printf "%b" "This option is not ready. Stay tuned!"
        exit 0
	;;
      f)  #set option "f"
	shift $((OPTIND-1))
	if [[ -z "${1}" ]]; then
	  arr=(`compgen -A function | grep '__' | sed 's/__//g'`)
    printf '%-14s status\n' "bin"
    printf '%.0s-' {1..30}; echo
    for tttt in "${arr[@]}"
    do
      type -p "${tttt}" &>/dev/null
      if [[ $? == 0 ]]; then
        printf '%-14s found\n' "${tttt}"
      else
        printf '%-14s not found\n' "${tttt}"
      fi
    done
	else
	  if ( compgen -A function "__${1}"); then
	    eval "__${1}" 'help'
	  else
	    echo "Function '${1}' not found." >/dev/tty
	  fi
	fi
	exit 0
	;;
      i) #--init
	      echo "Initialize configuration file?" >/dev/tty
	      exit 0
	               ;;
               n) # use osx notifications
	               shift $((OPTIND-1))
	               break
	               ;;
               q) # set 'q'
	               __manifest &> /dev/null &
	               exit 0
	               ;;
               t) # set 't'
	               shift $((OPTIND-1))
	               sytem=1
	               __manifest
	               ;;
               v) #set option "v"
	               printf 'v0.8.9 β\n' >/dev/tty
	               exit 0
	               ;;
               h)  #show help
	               func_menu_help
	               exit 0
	               ;;
               \?) #unrecognized option - show help
	               printf 'Unknown option.\n'
	               printf 'Use -h for helpful info.\n'
	               exit 2
	               ;;
    esac
  done
  #
  #
  for tryFunction in "${@}"
  do
    if type -t "__$tryFunction" >/dev/null; then
      "__$tryFunction" false
      shift
    else
      printf 'Invalid choice.\n'
      exit 1
    fi
  done
fi
#
#
exit
#
###################################
# SECTION: Thanks, man.
###################################
# /u/geirha @ reddit
# thkala @ SO
# Dave Dopson @ SO ; http://stackoverflow.com/a/246128
# /u/arturkomarov @ disqus
# Louis Marascio
# Emacs, Gem, Macports, NPM
# #bash on Freenode
