#!/usr/bin/env bash
###################################
# Disclaimer: THIS IS AN ACTIVE EXPERIMENT. EXECUTE AT YOUR OWN PERIL.
###################################
# SECTION: News.

###################################
# Manifest -- a project dedicated to the paranoid.
# Manifest is written for and tested on Bash on OSX.
# Purpose: To generate and maintain 'manifests' of applications/gems/modules/packages/ports/etc.
## To mirror a user's environment.
# Execution: To be run either as a cron job or from a shell.
###################################
# SECTION: Requirements.
###################################
# Bash 4.2
# Pallet and Cask for Emacs 24
###################################
# SECTION: Variables.
###################################
# Script Owner (GNU Bash on Darwin)
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
_CWD="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
#
_OWNER="$(stat -f %Su "${BASH_SOURCE[0]}")" # Find script owner
_RC_CWD="${_CWD}/.manifestrc"
_RC_HOME="${HOME}/.manifestrc" # must be fullpath or i could use `stat -f %N path`
#
_LOG="${HOME}/Library/logs/manifest.log"
###################################
# SECTION: Prepare environment.
###################################

unset CDPATH
hash -r # update hash table
# required for nice globbing stuff
## resets
_BASE=
_PKGS=
_SearchPaths=
_SavePaths=
_isTerm=

## Check for version number
_Major="${BASH_VERSINFO[0]}"
_Minor="${BASH_VERSINFO[1]}"
_Version="${_Major}.${_Minor}"
_requiredVersion=4.2
#


# check for config file
function checkRC () {
  if [[ -f "${_RC_CWD}" ]]; then
    printf 'RC file found in CWD.\n'
    . "${_RC_CWD}"
  elif [[ -f "${_RC_HOME}" ]]; then
    printf 'RC file found in HOME.\n'
    . "${_RC_HOME}"
    return
  else
    printf 'Configuration file is required!\n'
    exit 1
  fi
} &> "${_LOG}"


checkVersion () {
  ## compatibility
  if (( $(bc <<< "${_Version} >= ${_requiredVersion}") )); then
    printf 'Version requirement met.\n'
  else
    printf 'Fail!. Version %s is required!\n' "${_requiredVersion}"
    exit 1
  fi
} &> "${_LOG}"


# save time by not parsing everything unnecessarily
checkVersion
checkRC

function init () {

  printf '\n\n%s\n' "$(timeStamp)"
  ## terminal check
  if [[ -t 0  || -t 1 ]]; then
    printf "Running in Terminal.\n"
    _isTerm=1
  else
    printf 'Not-a-terminal.\n'
    _isTerm=0
  fi
  ##
  ##
  ##
  ##
  # _BASE *must* be defined and non-null
  if [[ -v _BASE && -n "${_BASE}" && -d "/${_BASE}/" ]]; then
    printf '_BASE is defined as %s\n' "${_BASE,,//\/\//\/}"
  else
    printf %b '_BASE must be defined and directory path must exist!\n'
    exit 1
  fi
  #
  #
  # package managers
  [[ -n "${_PKGS[*]}" ]] || printf 'No package managers defined.\n'
  #
  #
  #
  ####
  # default vars
  notify=0
}


# Reset log file. (user should have a choice in the matter)
#>"${_LOG}" # create/reset log, might be causing trouble with readline

###################################
# SECTION: Primary Functions.
###################################
# FUNCTION: Main
function __manifest() {
  notify "manifest core is running."

  /usr/bin/osascript -e "display notification \"That is all, $_OWNER \" "
  printf 'That is all, %s! (^.^)\n' "${_OWNER}"  >/dev/tty
}
#
#
# FUNCTION: Copy dotfiles.
function __dot() {
  # Ensure the directory exists.
  if [[ $1 == 'help' ]]; then
    cat <<EOM
$(termWidth)
Backup User dotFiles found in the HOME directory.
$(termWidth)
EOM
    exit 0
  fi
  # shellcheck disable=2174
  mkdir -p -m 744 "${_BASE}/dots/"
  rsync -cpRz "${HOME}"/.??*[!~$] "${_BASE}/dots/"
  rm -f "${_BASE}/dots/CLONE"*
  touch "${_BASE}/dots/CLONE.$(timeStamp)"
  #
  printf 'done.\n' >/dev/tty
  notify "${FUNCNAME[0]} is complete."
  exit 0
} &> "${_LOG}" # This syntax allows for stdout and stderr to be *appended* to log file.
#
#
# FUNCTION manifest of background services
function __services () {

  type lunchy &>/dev/null || { printf "I require the lunchy gem but it's not installed. Aborting."; exit 1;}

  lunchy list > "${_BASE}${USER}.background-services.txt"

  printf 'Generating %s manifest of %s...' "${FUNCNAME[0]#__}" "${_OWNER}" >/dev/tty

  printf 'done.\n' >/dev/tty
  notify "${FUNCNAME[0]} is complete."
}


# FUNCTION: Generate 'Gemfile' to use for reinstalling 'local' gems.
function __gem() {
  if [[ $1 == 'help' ]]; then
    cat >/dev/tty <<EOM
$(termWidth)
Create an execute-ready manifest of ruby gems.
$(termWidth)
EOM
    exit 0
  fi
  #
  type gem &>/dev/null || { printf "I require GEM but it's not installed. Aborting."; exit 1;}
  # need to properly parse output so that it can used on the command line
  printf 'Generating %s manifest...' "${FUNCNAME[0]#__}" >/dev/tty
  #thanks to arturkomarov @ disqus

  gem list | sed 's/(//'|sed 's/)//'|awk '{print "gem install " $1 " --version=" $2}' > "${_BASE}local.gems.txt"
  #
  printf 'done.\n' >/dev/tty
  #
  #
  printf "Executing next requested function.\n"
  notify "${FUNCNAME[0]} is complete."
  "${1}" && exit 0
}

#
# FUNCTION: Generate a 'package.json' for NPM global modules.
function __npm() {
  if [[ $1 == 'help' ]]; then
    cat >/dev/tty <<EOM
$(termWidth)
Create a manifest of global npm modules.
$(termWidth)
EOM
    exit 0
  fi
  type npm &>/dev/null || { echo >&2 "I require npm but it's not installed. Aborting."; exit 1;}
  printf 'Generating %s manifest...\n' "${FUNCNAME[0]#__}" >/dev/tty
  npm -g ls --json true --parseable true --depth=0 1> "${_BASE}npm-global.json" 2> "${_LOG}"
  #
  printf 'done.\n' >/dev/tty

  # continue
  notify "${FUNCNAME[0]#__} is complete."
  "${1}" && exit 0
} &> "${_LOG}"
#
# FUNCTION: Emacs stuff.
function __emacs() {
  if [[ $1 == 'help' ]]; then
    cat >/dev/tty <<EOM
$(termWidth)
Create a 'cask' manifest.
$(termWidth)
EOM
    exit 0
  fi
  #test
  type emacs &>/dev/null || { echo >&2 "I require emacs but it's not installed. Aborting."; exit 1;}
  #
  # generate cask file
  emacs --batch --eval "(progn (package-initialize)
(if (bound-and-true-p pallet-mode)
(pallet-init)
(progn
(pallet-mode)
(pallet-init))))"

  #
  printf 'Generating %s (cask) manifest...' "${FUNCNAME[0]#__}" >/dev/tty
  cp -p "${HOME}/.emacs.d/Cask" "${_BASE}"
  #
  printf 'done.\n' >/dev/tty
  notify "${FUNCNAME[0]#__} is complete."
  #continue
  "${1}" && exit

} &> "${_LOG}"
#
# Function: create system apps manifest.
function __sysApps() {
  if [[ $1 == 'help' ]]; then
    cat >/dev/tty <<EOM
$(termWidth)
Create a manifest of Applications.
$(termWidth)
EOM
    exit 0
  fi
  #
  printf 'Generating %s %s manifest...' "$(sw_vers -productVersion)" "${FUNCNAME[0]#__}" >/dev/tty
  printf "Archived:\n$(mdfind -onlyin /Applications/ kMDItemKind == Application | tee >(wc -l) | sort -f;) \n\n\n" > "${_BASE}system.apps.txt"
  #

  printf 'done.\n' >/dev/tty
  notify "${FUNCNAME[0]} is complete."
  # continue
  "${1}" && exit 0
}
#
# # manifest of all installed macports ports
function __port() {
  if [[ $1 == 'help' ]]; then
    cat >/dev/tty <<EOM
$(termWidth)
Create a manifest of installed and requested Macports ports.
$(termWidth)
EOM
    exit 0
  fi

  type port &>/dev/null  || { echo >&2 "I require the Macports port, but it's not installed. Aborting."; exit 1; }
  # Credit: Macports
  printf 'Generating %s manifest...' "${FUNCNAME[0]#__}" >/dev/tty
  port -qv installed > "${_BASE}system.macports.txt"
  printf 'done.\n' >/dev/tty
  printf "Creating manifest of requested ports..." >/dev/tty

  port echo requested | cut -d ' ' -f 1 > "${_BASE}system.macports-requested.txt"
  #
  printf 'done.\n' >/dev/tty
  notify "${FUNCNAME[0]} is complete."
  "${1}" && exit 0
}
#
function __cron() {
  # crontabs
  printf 'Replicating crontab of use %s...' "${_OWNER}" >/dev/tty
  crontab -l > "${_BASE}${USER}.crontab.txt"
  #
  printf 'done.\n' >/dev/tty
  notify "${FUNCNAME[0]} is complete."
  "$1" && exit 0
}
#&> notify
#&>"${_LOG}"
#
function __apache() {
  if [[ $1 == 'help' ]]; then
    cat >/dev/tty <<EOM
$(termWidth)
This option will copy important server files.
$(termWidth)
EOM
    exit 0
  fi
  type httpd &>/dev/null || { echo >&2 "I require HTTPD but it's not installed. Aborting."; exit 1;}
  # Permissions?
  _HTTPD_ROOT="$(httpd -V | grep -Po '(?<=HTTPD_ROOT\=\")[^"]*')"
  _HTTPD_SERVER_CONFIG="${_HTTPD_ROOT}/$(httpd -V | grep -Po '(?<=SERVER_CONFIG_FILE\=\")[^"]*')"
  _HTTPD_VHOST_CONFIG="${_HTTPD_ROOT}/conf/extra/httpd-vhosts.conf"
  _HTTPD_MIME_CONFIG="${_HTTPD_ROOT}/$(httpd -V | grep -Po '(?<=AP_TYPES_CONFIG_FILE\=\")[^"]*')"

  #backup includes
  while IFS= read -r result
  do
    cp -p "${_HTTPD_ROOT}/${result}" "${_BASE}/serverFiles/"
  done < <(grep -iPo "(?<=include\s).*conf\/.*" /opt/local/apache2/conf/httpd.conf)


#type php &>/dev/null || { echo >&2 "I require HTTPD but it's not installed. Aborting."; exit 1;}

_PHP_INI="$(php -r 'echo php_ini_loaded_file();')"


# shellcheck disable=2174
mkdir -p -m 744 "${_BASE}/serverFiles/"
#
cp -p "${_HTTPD_SERVER_CONFIG}" \
   "${_HTTPD_VHOST_CONFIG}" \
   '/etc/resolv.conf' \
   '/etc/hosts' \
   '/opt/local/etc/dnsmasq.conf' \[<64;96;10M
   '/opt/local/apache2/conf/extra/mod_php56.conf' \
   "${_HTTPD_MIME_CONFIG}" "${_BASE}/serverFiles/"

notify "${FUNCNAME[0]} is complete."
}

#
function __getUser() {
  stat -f %Su "${BASH_SOURCE[0]}"
}
#
###################################
# SECTION: Auxilary Functions.
###################################
# FUNCTION:
function notify () {
  #apple
  [[ "$_isTerm" -eq 1 && "$notify" -eq 1 ]] && osascript -e "display notification \"$1\" with title \"manifest $ \""
}

function errorHandle() {
  osascript -e 'display notification "Someone setup us the bomb!" with title "Sorry, a system error occurred."'
}

# sanitizing paths
function cleanPath () {
  shopt -s extglob
  printf '%s\n' "${1//+(\/)//}"
  shopt -u extglob
}

# FUNCTION:
function timeStamp() {
  date +%Y.%m.%d.%H.%M.%S
}

# FUNCTION:
function termWidth() {
  printf -v sep '%*s' "$(tput cols)" ; echo "${sep// /-}"
}
#
#
###################################
# SECTION: Execute.
###################################
# Menu functions
function func_menu_help() {
  cat <<EOM
$(termWidth)
manifest -- execute, in case of Doomsday.
A Bash program that generates parseable package manifests using the
syntax of respective package managers. All designed with love for the paranoid.

-c: show example config (RC) file
-f: list functions; takes optional argument
-i: interactively create a .manifestrc file
-q: quiet mode
-v: print version
-h: get help, seriously
$(termWidth)
EOM
}
#
#
#
init
#
#
if ((!$#))
then
  __manifest
else
  while getopts acfinq:tvh FLAG; do

    case $FLAG in
      a) #set a
        shift $((OPTIND-1))
	echo win >/dev/tty
	exit 0
	;;
      c) #--config
        shift $((OPTIND-1))
        printf "%b" "Not ready."
        exit 0
	;;
      f)  #set option "f"
	shift $((OPTIND-1))
	if [[ -z "${1}" ]]; then
	  compgen -A function | grep '__' | sed 's/__//g'

	else
	  if ( compgen -A function "__${1}"); then
	    eval "__${1}" 'help'
	  else
	    echo "Function '${1}' not found." >/dev/tty
	  fi
	fi
	exit 0
	;;
      i) #--init
	echo "Initialize configuration file?" >/dev/tty
	exit 0
	;;
      n) # use osx notifications
	shift $((OPTIND-1))
	notify=1
	break
	;;
      q) # set 'q'
	__manifest &> /dev/null &
	exit 0
	;;
      t) # set 't'
	shift $((OPTIND-1))
	sytem=1
	__manifest
	;;
      v) #set option "v"
	printf 'β\n' >/dev/tty
	exit 0
	;;
      h)  #show help
	func_menu_help
	exit 0
	;;
      \?) #unrecognized option - show help
	printf 'Unknown option.\n'
	printf 'Use -h for helpful info.\n'
	exit 2
	;;
    esac
  done
  #
  #
  for tryFunction in "${@}"
  do
    if type -t "__$tryFunction" >/dev/null; then
      "__$tryFunction" false
      shift
    else
      printf 'Invalid choice.\n'
      exit 1
    fi
  done
fi
#
#
exit
#
###################################
# SECTION: Thanks, man.
###################################
# /u/geirha @ reddit
# thkala @ SO
# Dave Dopson @ SO ; http://stackoverflow.com/a/246128
# /u/arturkomarov @ disqus
# Louis Marascio
# Emacs, Gem, Macports, NPM
# #bash on Freenode
